#!/usr/bin/env python3
"""
Code-generating agent that uses OpenAI Vision API to generate Python code
which is then executed to determine game actions.
"""

import openai
import os
import time
import io
import base64
from utils.llm_logger import get_llm_logger
from utils.state_formatter import format_state_for_llm_json, convert_state_to_dict
from utils.milestone_manager import MilestoneManager
from utils.prompt_builder import CodeAgentPromptBuilder, CodePromptConfig
from utils.stuck_detector import StuckDetector
from utils.knowledge_base import KnowledgeBase
from utils.subtask_manager import SubtaskManager


class CodeAgent:
    """Agent that generates and executes Python code to determine actions"""

    def __init__(self):
        """Initialize the CodeAgent with OpenAI client and logger"""
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise ValueError("OPENAI_API_KEY environment variable not set")

        self.client = openai.OpenAI(api_key=api_key)
        self.llm_logger = get_llm_logger()
        self.model = "gpt-5"
        self.step_count = 0
        self.last_code_generation_step = 0

        # Milestone manager (like SimpleAgent's objectives)
        self.milestone_manager = MilestoneManager()

        # Subtask manager for dynamic task decomposition
        self.subtask_manager = SubtaskManager(self.milestone_manager)

        # Subtask feature flag (enable/disable subtask-based execution)
        self.use_subtasks = os.getenv("USE_SUBTASKS", "false").lower() == "true"

        # Custom milestone completion tracking (client-side only)
        self.custom_milestone_completions = {}

        # Stuck detector (threshold=3)
        self.stuck_detector = StuckDetector(threshold=3)

        # Code caching
        self.last_generated_code = None
        self.code_generation_count = 0

        # Execution error tracking
        self.last_execution_error = None

        # Prompt builder for structured prompt generation
        self.prompt_builder = CodeAgentPromptBuilder(
            config=CodePromptConfig(
                include_visual_note=True,
                include_milestones=True,
                include_example_code=True
            )
        )

        # Knowledge base for persistent learning across runs
        self.knowledge_base = KnowledgeBase()

        # Track actions generated by current code (for debugging stuck patterns)
        self.actions_since_last_generation = []

        # Track last action for custom milestone checking
        self._last_action = None

        # Register custom milestones
        self._register_custom_milestones()

    def step(self, game_state):
        """
        Generate code based on game state and execute it to get action

        StuckÏù¥ ÏïÑÎãê ÎïåÎäî Ïù¥Ï†Ñ ÏΩîÎìú Ïû¨ÏÇ¨Ïö©, StuckÏùº ÎïåÎßå ÏÉà ÏΩîÎìú ÏÉùÏÑ±

        Args:
            game_state: Dict with keys:
                - 'frame': PIL Image
                - 'player': player info dict
                - 'game': game info dict
                - 'map': map info dict
                - 'visual': visual info dict

        Returns:
            {'action': 'up'} or {'action': ['up', 'a']}
        """
        self.step_count += 1

        # NEW: Subtask-based execution (if enabled)
        if self.use_subtasks:
            return self._step_with_subtasks(game_state)

        # 1. Check for stuck pattern
        is_stuck = self.stuck_detector.check_stuck(game_state)

        # 2. Code selection logic
        try:
            steps_since_generation = self.step_count - self.last_code_generation_step
            if self.last_execution_error or is_stuck or self.last_generated_code is None or steps_since_generation >= 30:
                # ÏóêÎü¨ ÏûàÍ±∞ÎÇò, StuckÏù¥Í±∞ÎÇò, Ï≤´ Ïã§Ìñâ, ÎòêÎäî 60Ïä§ÌÖù Í≤ΩÍ≥º -> ÏÉà ÏΩîÎìú ÏÉùÏÑ±
                code = self._generate_new_code(game_state, is_stuck)
                self.last_generated_code = code
                self.code_generation_count += 1
                self.last_code_generation_step = self.step_count
            else:
                # Not stuck and no error -> Ïù¥Ï†Ñ ÏΩîÎìú Ïû¨ÏÇ¨Ïö©
                code = self.last_generated_code
                print(f"üîÑ Reusing previous code (generation #{self.code_generation_count})")

            # 3. Execute code to get action
            action = self._execute_code(code, game_state)

            # 4. Check custom milestones AFTER action is generated
            self._check_custom_milestones(game_state, action)

            # 5. Record action and reset if stuck
            self.stuck_detector.record_action(action)
            self.actions_since_last_generation.append(action)
            self._last_action = action
            if is_stuck:
                self.stuck_detector.reset()

            return {'action': action}

        except Exception as e:
            print(f"‚ùå CodeAgent error: {e}")
            return {'action': 'b'}  # Default action on error

    def _generate_new_code(self, game_state, is_stuck: bool) -> str:
        """
        ÏÉàÎ°úÏö¥ ÏΩîÎìú ÏÉùÏÑ± (LLM Ìò∏Ï∂ú)

        Args:
            game_state: Í≤åÏûÑ ÏÉÅÌÉú
            is_stuck: Stuck Ïó¨Î∂Ä

        Returns:
            ÏÉùÏÑ±Îêú Python ÏΩîÎìú
        """
        # 0. Save previous actions before generating new code, then reset
        previous_actions = self.actions_since_last_generation.copy()
        self.actions_since_last_generation = []

        # 1. Stuck warning ÏÉùÏÑ±
        stuck_warning = self.stuck_detector.get_stuck_warning()

        # 2. Ïù¥Ï†Ñ ÏΩîÎìú (stuckÏù∏ Í≤ΩÏö∞Îßå, raw codeÎßå Ï†ÑÎã¨)
        previous_code_raw = ""
        if is_stuck and self.last_generated_code:
            previous_code_raw = self.last_generated_code

        # 3. StateÏôÄ milestone Ï†ïÎ≥¥ (JSON ÌòïÌÉúÎ°ú Î≥ÄÌôò)
        state_text = format_state_for_llm_json(game_state)
        screenshot_base64 = self._get_screenshot_base64(game_state)

        # Get augmented milestones (server's + custom)
        augmented_milestones = self._get_augmented_milestones(game_state)
        next_milestone_info = self.milestone_manager.get_next_milestone_info(augmented_milestones)
        current_milestone = next_milestone_info['id'] if next_milestone_info else 'unknown'

        # 4. Knowledge base Í∞ÄÏ†∏Ïò§Í∏∞
        knowledge_text = self.knowledge_base.to_prompt_format(limit=20)

        # 5. ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ± (raw code Ï†ÑÎã¨, Ìè¨Îß∑ÌåÖÏùÄ PromptBuilderÍ∞Ä Îã¥Îãπ)
        prompt = self.prompt_builder.build_prompt(
            formatted_state=state_text,
            next_milestone_info=next_milestone_info,
            stuck_warning=stuck_warning,
            previous_code=previous_code_raw,
            execution_error=self.last_execution_error,
            knowledge_base=knowledge_text,
            previous_actions=previous_actions
        )

        # 6. LLM Ìò∏Ï∂ú
        start = time.time()
        response = self.client.responses.create(
            model=self.model,
            instructions="You are a Pokemon Emerald AI coding assistant. Generate clean, executable Python code based on visual and text information.",
            input=[
                {
                    "role": "user",
                    "content": (
                        [{"type": "input_text", "text": prompt}]
                        if not screenshot_base64
                        else [
                            {"type": "input_text", "text": prompt},
                            {"type": "input_image",
                            "image_url": f"data:image/png;base64,{screenshot_base64}"}  # data URL ÌóàÏö©
                        ]
                    )
                }
            ],
            reasoning={"effort": "low"}  # reasoning Î™®Îç∏ÏóêÏÑúÎßå ÏùòÎØ∏ ÏûàÏùå
        )

        duration = time.time() - start

        # 7. ÏΩîÎìú Ï∂îÏ∂ú Î∞è Î°úÍπÖ
        full_response = response.output_text
        code = self._extract_code(full_response)

        # 8. Knowledge base ÏóÖÎç∞Ïù¥Ìä∏ ÌååÏã±
        self._parse_and_update_knowledge(full_response, current_milestone)

        self.llm_logger.log_interaction(
            interaction_type="code_generation",
            prompt=prompt,
            response=full_response,
            duration=duration,
            model_info={
                "model": self.model,
                "tokens": {
                    "prompt": 0,
                    "completion": 0
                    # "prompt": response.usage.prompt_tokens,
                    # "completion": response.usage.completion_tokens
                }
            }
        )

        # 7. Milestone Ï†ïÎ≥¥ Ï∂úÎ†•
        if next_milestone_info:
            print(f"üìç Next Milestone: {next_milestone_info['id']}")
        else:
            print(f"üèÜ All Milestones Complete!")

        # 8. ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±ÌñàÏúºÎ©¥ ÏóêÎü¨ Ï¥àÍ∏∞Ìôî
        self.last_execution_error = None

        return code

    def _get_screenshot_base64(self, game_state):
        """Get base64 screenshot from game state"""
        frame = game_state.get('frame')
        if frame:
            buffer = io.BytesIO()
            frame.save(buffer, format='PNG')
            return base64.b64encode(buffer.getvalue()).decode()
        return ""

    def _extract_code(self, text):
        """Extract code from structured LLM response"""
        # Try to find CODE: section first (for structured responses)
        if "CODE:" in text:
            code_section = text.split("CODE:")[1]

            # Extract from code block if present
            if "```python" in code_section:
                return code_section.split("```python")[1].split("```")[0].strip()
            elif "```" in code_section:
                return code_section.split("```")[1].split("```")[0].strip()

            # If no code block, take everything after CODE:
            # until we hit another section or end
            lines = code_section.split('\n')
            code_lines = []
            for line in lines:
                # Stop at next section header
                if any(line.strip().startswith(section) for section in ['ANALYSIS:', 'OBJECTIVES:', 'PLAN:', 'REASONING:']):
                    break
                code_lines.append(line)

            extracted = '\n'.join(code_lines).strip()
            if extracted:
                return extracted

        # Fallback to old behavior (for non-structured responses)
        if "```python" in text:
            return text.split("```python")[1].split("```")[0].strip()
        elif "```" in text:
            return text.split("```")[1].split("```")[0].strip()

        return text.strip()

    def _execute_code(self, code, state):
        """
        Execute generated code and extract action

        Args:
            code: Python code string with run(state) function
            state: Game state dict (raw format)

        Returns:
            action string (e.g., 'up', 'a')
        """
        try:
            # Convert state to same format LLM saw in prompt
            formatted_state = convert_state_to_dict(state)

            # Create execution environment
            exec_globals = {}
            exec(code, exec_globals)

            # Call run function with formatted state
            if 'run' in exec_globals:
                action = exec_globals['run'](formatted_state)

                # Validate action (support single action or list of actions)
                valid_actions = ['a', 'b', 'start', 'select', 'up', 'down', 'left', 'right']

                # Support single action (str)
                if isinstance(action, str):
                    if action.lower() in valid_actions:
                        return action.lower()
                    else:
                        error_msg = f"Invalid action returned: {action}"
                        print(f"‚ö†Ô∏è {error_msg}, using 'b'")
                        self.last_execution_error = {
                            'error': error_msg,
                            'code': code
                        }
                        return 'b'

                # Support multiple actions (list)
                elif isinstance(action, list):
                    if len(action) == 0:
                        error_msg = "Empty action list returned"
                        print(f"‚ö†Ô∏è {error_msg}, using 'b'")
                        self.last_execution_error = {
                            'error': error_msg,
                            'code': code
                        }
                        return 'b'

                    # Validate each action in the list
                    validated_actions = []
                    for act in action:
                        if isinstance(act, str) and act.lower() in valid_actions:
                            validated_actions.append(act.lower())
                        else:
                            error_msg = f"Invalid action in list: {act}"
                            print(f"‚ö†Ô∏è {error_msg}, using 'b'")
                            self.last_execution_error = {
                                'error': error_msg,
                                'code': code
                            }
                            return 'b'

                    return validated_actions  # Return list of validated actions

                # Invalid type
                else:
                    error_msg = f"Invalid action type returned: {type(action).__name__} (expected str or list)"
                    print(f"‚ö†Ô∏è {error_msg}, using 'b'")
                    self.last_execution_error = {
                        'error': error_msg,
                        'code': code
                    }
                    return 'b'
            else:
                error_msg = "No 'run' function found in code"
                print(f"‚ö†Ô∏è {error_msg}, using 'b'")
                self.last_execution_error = {
                    'error': error_msg,
                    'code': code
                }
                return 'b'

        except Exception as e:
            import traceback
            error_msg = f"Code execution error: {str(e)}"
            traceback_str = traceback.format_exc()

            print(f"‚ùå {error_msg}")
            print(f"Code:\n{code}")
            print(traceback_str)

            self.last_execution_error = {
                'error': error_msg,
                'code': code,
                'traceback': traceback_str
            }

            return 'b'  # Default action on error

    def _parse_and_update_knowledge(self, llm_response: str, current_milestone: str):
        """
        Parse LLM response for ADD_KNOWLEDGE commands and update knowledge base

        Args:
            llm_response: Full LLM response text
            current_milestone: Current milestone ID for metadata
        """
        for line in llm_response.split('\n'):
            line = line.strip()
            if line.startswith("ADD_KNOWLEDGE:"):
                # Extract content after "ADD_KNOWLEDGE:"
                content = line.split("ADD_KNOWLEDGE:", 1)[1].strip()
                if content:
                    # Add to knowledge base with current step and milestone
                    self.knowledge_base.add(
                        content=content,
                        step=self.step_count,
                        milestone=current_milestone
                    )
                    print(f"üìù Knowledge added: {content}")

    def _register_custom_milestones(self):
        """Register custom milestones with completion conditions"""

        # Example: Clock interaction in bedroom
        def check_clock_interact(game_state, action):
            """
            Check if clock interaction happened:
            - Player at position (5, 2) - the tile BEFORE moving up to the clock
            - Action: exactly ['up', 'a'] sequence (move up to clock, then interact)

            Note: We check position BEFORE action execution, so we check (5,2) not (5,1).
            Action sequence must be exactly 2 actions in order.
            Single actions or sequences longer than 2 will not count.
            """
            player = game_state.get("player", {})
            pos = player.get("position", {})

            # Must be at position (5,2) - the tile before moving up to clock at (5,1)
            if not (pos.get("x") == 5 and pos.get("y") == 2):
                return False

            # Must be a list action with exactly ['up', 'a']
            if isinstance(action, list):
                return (len(action) == 2 and
                        action[0] == 'up' and
                        action[1] == 'a')

            # Single actions don't count
            return False

        # Add to milestone manager
        self.milestone_manager.add_custom_milestone(
            milestone_id="CLOCK_INTERACT",
            description="From position (5,2) in player bedroom, execute action sequence ['up', 'a'] to move up to the clock and interact with it",
            insert_after="PLAYER_BEDROOM",
            check_fn=check_clock_interact,
            category="custom"
        )

        # Example: Leave the house (same condition as CLOCK_SET)
        def check_leave_house(game_state, action):
            """
            Check if player left the house (same logic as CLOCK_SET):
            - Player location must be in Littleroot Town
            - NOT in any house or lab (outside)

            Note: This is a location-based check, action parameter is not used.
            Prerequisite check (CLOCK_INTERACT completed) is handled by _check_custom_milestones.
            """
            player = game_state.get("player", {})
            location = player.get("location", "")
            location_upper = str(location).upper()

            # In Littleroot but NOT in either house or lab
            return ("LITTLEROOT" in location_upper and
                    "HOUSE" not in location_upper and
                    "LAB" not in location_upper)

        # Add to milestone manager
        self.milestone_manager.add_custom_milestone(
            milestone_id="LEAVE_HOUSE",
            description="Leave the house and return to Littleroot Town (outside)",
            insert_after="CLOCK_INTERACT",
            check_fn=check_leave_house,
            category="custom"
        )

    def _check_custom_milestones(self, game_state, action):
        """
        Check and track custom milestone completions (client-side only)

        Args:
            game_state: Current game state from server
            action: Action that was just executed
        """
        # Get augmented milestones (server's + custom)
        milestones = self._get_augmented_milestones(game_state)

        for custom in self.milestone_manager.custom_milestones:
            milestone_id = custom["id"]

            # Skip if already completed
            if milestones.get(milestone_id, {}).get('completed', False):
                continue

            # Check if previous milestone is completed
            insert_after_id = custom["insert_after"]
            if not milestones.get(insert_after_id, {}).get('completed', False):
                continue

            # Check condition
            check_fn = custom["check_fn"]
            try:
                if check_fn(game_state, action):
                    print(f"üéØ Custom milestone completed: {milestone_id}")
                    self.custom_milestone_completions[milestone_id] = {
                        'completed': True,
                        'timestamp': time.time()
                    }
            except Exception as e:
                print(f"‚ö†Ô∏è Error checking custom milestone {milestone_id}: {e}")

    def _get_augmented_milestones(self, game_state):
        """
        Merge server's milestones with client's custom milestone completions

        Args:
            game_state: Game state from server

        Returns:
            Combined milestone dict (server + custom)
        """
        # Start with server's milestones
        milestones = game_state.get('milestones', {}).copy()

        # Add custom milestone completions
        milestones.update(self.custom_milestone_completions)

        return milestones

    def determine_situation(self, current_subtask, state):
        """
        Determine current situation for subtask-based processing

        Args:
            current_subtask: Current active subtask dict (or None)
            state: Current game state dict

        Returns:
            str: One of "SUCCESS_ACHIEVED", "PRECONDITION_FAILED", "STUCK", "NORMAL"
        """
        # No subtask = NORMAL (initial state or progressing without subtasks)
        if not current_subtask:
            return "NORMAL"

        # Get last action for condition evaluation
        prev_action = self._last_action

        # Check SUCCESS condition first
        if current_subtask.get('success_condition'):
            try:
                if self.subtask_manager.evaluate_condition(
                    current_subtask['success_condition'], state, prev_action
                ):
                    return "SUCCESS_ACHIEVED"
            except Exception as e:
                print(f"‚ö†Ô∏è Error evaluating success condition: {e}")

        # Check PRECONDITION
        if current_subtask.get('precondition'):
            try:
                if not self.subtask_manager.evaluate_condition(
                    current_subtask['precondition'], state, prev_action
                ):
                    return "PRECONDITION_FAILED"
            except Exception as e:
                print(f"‚ö†Ô∏è Error evaluating precondition: {e}")

        # Check STUCK (using existing stuck detector)
        if self.stuck_detector.check_stuck(state):
            return "STUCK"

        # Otherwise NORMAL (progressing normally)
        return "NORMAL"


    def parse_unified_response(self, response):
        """
        Parse VLM response for subtask-based code generation

        Extracts three main sections:
        - TASK_DECOMPOSITION: Decision on subtask management
        - CONDITION_REFINEMENT: Updated preconditions/success conditions
        - CODE: Policy implementation

        Args:
            response: VLM response string

        Returns:
            dict with:
                - task_decision: 'KEEP_CURRENT' | 'CREATE_NEW' | 'DECOMPOSE'
                - new_subtask: dict with description, precondition, success_condition (if CREATE_NEW/DECOMPOSE)
                - refined_precondition: str (if refined)
                - refined_success: str (if refined)
                - code: str (policy code)
        """
        result = {}

        try:
            # Extract TASK_DECOMPOSITION section
            decomp_section = self._extract_section(response, 'TASK_DECOMPOSITION:', 'CONDITION_REFINEMENT:')

            # Parse decision
            decision_line = [line for line in decomp_section.split('\n') if 'Decision:' in line]
            if decision_line:
                decision_text = decision_line[0].split('Decision:')[-1].strip().upper()

                if 'KEEP_CURRENT' in decision_text:
                    result['task_decision'] = 'KEEP_CURRENT'
                elif 'CREATE_NEW' in decision_text:
                    result['task_decision'] = 'CREATE_NEW'
                elif 'DECOMPOSE' in decision_text:
                    result['task_decision'] = 'DECOMPOSE'
                else:
                    result['task_decision'] = 'KEEP_CURRENT'  # default
            else:
                result['task_decision'] = 'KEEP_CURRENT'  # default

            # If CREATE_NEW or DECOMPOSE, extract subtask info
            if result['task_decision'] in ['CREATE_NEW', 'DECOMPOSE']:
                desc = self._extract_after_marker(decomp_section, 'Description:')
                pre = self._extract_after_marker(decomp_section, 'Precondition:')
                succ = self._extract_after_marker(decomp_section, 'Success Condition:')

                if desc.strip():
                    result['new_subtask'] = {
                        'description': desc.strip(),
                        'precondition': pre.strip(),
                        'success_condition': succ.strip()
                    }
                else:
                    result['new_subtask'] = None
            else:
                result['new_subtask'] = None

            # Extract CONDITION_REFINEMENT section
            refine_section = self._extract_section(response, 'CONDITION_REFINEMENT:', 'CODE:')
            if 'NO_CHANGE' not in refine_section.upper():
                refined_pre = self._extract_after_marker(refine_section, 'PRECONDITION:')
                refined_succ = self._extract_after_marker(refine_section, 'SUCCESS_CONDITION:')

                if refined_pre.strip():
                    result['refined_precondition'] = refined_pre.strip()
                if refined_succ.strip():
                    result['refined_success'] = refined_succ.strip()

            # Extract CODE section (reuse existing _extract_code method)
            result['code'] = self._extract_code(response)

        except Exception as e:
            print(f"‚ö†Ô∏è Error parsing unified response: {e}")
            # Return safe defaults
            result = {
                'task_decision': 'KEEP_CURRENT',
                'new_subtask': None,
                'code': 'return "b"  # Parse error - wait'
            }

        return result

    def _extract_section(self, text, start_marker, end_marker):
        """
        Extract text between two markers

        Args:
            text: Source text
            start_marker: Starting marker (e.g., 'TASK_DECOMPOSITION:')
            end_marker: Ending marker (e.g., 'CONDITION_REFINEMENT:')

        Returns:
            Extracted section text
        """
        try:
            start_idx = text.find(start_marker)
            if start_idx == -1:
                return ""

            # Start after the marker
            start_idx += len(start_marker)

            end_idx = text.find(end_marker, start_idx)
            if end_idx == -1:
                # If no end marker, take until end of text
                return text[start_idx:].strip()

            return text[start_idx:end_idx].strip()

        except Exception as e:
            print(f"‚ö†Ô∏è Error extracting section {start_marker} to {end_marker}: {e}")
            return ""

    def _extract_after_marker(self, text, marker):
        """
        Extract text after a marker until the next line that starts with a capital letter marker

        Args:
            text: Source text
            marker: Marker to find (e.g., 'Description:')

        Returns:
            Extracted text
        """
        try:
            idx = text.find(marker)
            if idx == -1:
                return ""

            # Start after marker
            start = idx + len(marker)

            # Find next line
            lines = text[start:].split('\n')
            if not lines:
                return ""

            # First line after marker
            first_line = lines[0].strip()

            # Check if we need to look at subsequent lines
            # Stop at next capitalized marker (e.g., "Description:", "Precondition:")
            result = [first_line]
            for line in lines[1:]:
                stripped = line.strip()
                # Stop if we hit another marker (starts with capital and has colon)
                if stripped and stripped[0].isupper() and ':' in stripped:
                    break
                if stripped:  # Non-empty line
                    result.append(stripped)

            return ' '.join(result).strip()

        except Exception as e:
            print(f"‚ö†Ô∏è Error extracting after marker {marker}: {e}")
            return ""

    def create_next_subtask(self, main_milestone, subtask_data, state):
        """
        Create next subtask (only one at a time)

        Args:
            main_milestone: Main milestone dict
            subtask_data: dict with description, precondition, success_condition
            state: Current game state

        Returns:
            Created subtask dict
        """
        from datetime import datetime

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        subtask_id = f"{main_milestone['id']}_subtask_{timestamp}"

        subtask = {
            'id': subtask_id,
            'parent_milestone_id': main_milestone['id'],
            'description': subtask_data['description'],
            'precondition': subtask_data.get('precondition', ''),
            'success_condition': subtask_data.get('success_condition', ''),
            'code': None,
            'created_at': timestamp
        }

        # Set in SubtaskManager (also registers as custom milestone)
        self.subtask_manager.set_current_subtask(subtask)

        print(f"üìç Created new subtask: {subtask['description']}")
        print(f"   Precondition: {subtask['precondition']}")
        print(f"   Success: {subtask['success_condition']}")

        return subtask

    def update_subtask_conditions(self, current_subtask, parsed):
        """
        Update precondition and/or success_condition of current subtask

        Args:
            current_subtask: Current subtask dict
            parsed: Parsed response with optional refined_precondition and refined_success

        Returns:
            Updated subtask dict
        """
        if not current_subtask:
            return None

        updated = False

        if parsed.get('refined_precondition'):
            current_subtask['precondition'] = parsed['refined_precondition']
            print(f"üîß Updated precondition: {parsed['refined_precondition']}")
            updated = True

        if parsed.get('refined_success'):
            current_subtask['success_condition'] = parsed['refined_success']
            print(f"üîß Updated success condition: {parsed['refined_success']}")
            updated = True

        # Re-register as custom milestone if updated
        if updated:
            self.subtask_manager._register_as_custom_milestone(current_subtask)

        return current_subtask

    def process_milestone_with_subtasks(self, frame, state, main_milestone):
        """
        Process milestone using subtask decomposition

        This is the main integration function that combines all subtask components.

        Args:
            frame: Game frame (PIL Image)
            state: Current game state
            main_milestone: Main milestone dict

        Returns:
            str: Action to take ('up', 'down', 'left', 'right', 'a', 'b')
        """
        # 1. Get current subtask
        current_subtask = self.subtask_manager.get_current_subtask()

        # 2. Determine situation
        situation = self.determine_situation(current_subtask, state)

        print(f"\n{'='*60}")
        print(f"Milestone: {main_milestone['description']}")
        print(f"Subtask: {current_subtask['description'] if current_subtask else 'None'}")
        print(f"Situation: {situation}")
        print(f"{'='*60}")

        # 3. Check if we can reuse existing code (NORMAL with code)
        if situation == "NORMAL" and current_subtask and current_subtask.get('code'):
            print("‚ÑπÔ∏è Reusing existing code...")
            try:
                action = self._execute_code(current_subtask['code'], state)
                return action
            except Exception as e:
                print(f"‚ö†Ô∏è Code execution failed: {e}")
                # Fall through to VLM call

        # 4. Need VLM call for any other situation
        print(f"ü§ñ Calling VLM for {situation} situation...")

        # Build prompt using PromptBuilder
        prompt = self.prompt_builder.build_subtask_prompt(
            main_milestone=main_milestone,
            current_subtask=current_subtask,
            situation=situation,
            state=state,
            milestone_manager=self.milestone_manager
        )

        # Call VLM and measure duration
        start = time.time()
        response = self._call_vlm(frame, prompt)
        duration = time.time() - start

        # 5. Parse response
        parsed = self.parse_unified_response(response)

        # 6. Log LLM interaction for playground.html AUTO mode
        self.llm_logger.log_interaction(
            interaction_type="code_generation",
            prompt=prompt,
            response=response,
            duration=duration,
            model_info={
                "model": self.model,
                "tokens": {
                    "prompt": 0,
                    "completion": 0
                }
            }
        )

        print(f"\nüìä VLM Decision: {parsed['task_decision']}")

        # 6. Handle task decomposition
        if parsed['task_decision'] in ['CREATE_NEW', 'DECOMPOSE']:
            if parsed.get('new_subtask'):
                # Create new subtask (replaces current)
                new_subtask = self.create_next_subtask(
                    main_milestone,
                    parsed['new_subtask'],
                    state
                )
                current_subtask = new_subtask
            else:
                print("‚ö†Ô∏è No subtask data provided despite CREATE_NEW/DECOMPOSE decision")

        # 7. Handle condition refinement
        if parsed.get('refined_precondition') or parsed.get('refined_success'):
            if current_subtask:
                current_subtask = self.update_subtask_conditions(current_subtask, parsed)

        # 8. Save code to current subtask
        if current_subtask and parsed.get('code'):
            current_subtask['code'] = parsed['code']

        # 9. Save subtask state
        if current_subtask:
            self.subtask_manager.save_state(main_milestone['id'])

        # 10. Execute code
        try:
            action = self._execute_code(parsed['code'], state)
            print(f"‚úÖ Action: {action}")
            return action
        except Exception as e:
            print(f"‚ùå Code execution failed: {e}")
            return 'b'  # Wait/back on error

    def _call_vlm(self, frame, prompt):
        """
        Call VLM with frame and prompt

        Args:
            frame: PIL Image
            prompt: Prompt string

        Returns:
            VLM response string
        """
        # Encode frame to base64
        if frame:
            buffer = io.BytesIO()
            frame.save(buffer, format='PNG')
            frame_b64 = base64.b64encode(buffer.getvalue()).decode()
        else:
            frame_b64 = ""

        # Call OpenAI
        messages = [
            {
                "role": "user",
                "content": [
                    {"type": "text", "text": prompt}
                ]
            }
        ]

        if frame_b64:
            messages[0]["content"].insert(0, {
                "type": "image_url",
                "image_url": {"url": f"data:image/png;base64,{frame_b64}"}
            })

        response = self.client.chat.completions.create(
            model=self.model,
            messages=messages,
            max_completion_tokens=4096
        )

        return response.choices[0].message.content

    def _step_with_subtasks(self, game_state):
        """
        Step function using subtask-based execution

        Args:
            game_state: Game state dict

        Returns:
            {'action': action_string}
        """
        try:
            # Get current milestone
            milestones = self._get_augmented_milestones(game_state)
            next_milestone_id = self.milestone_manager.get_next_milestone(milestones)

            if not next_milestone_id:
                print("üéâ All milestones completed!")
                return {'action': 'b'}  # Wait

            milestone_info = self.milestone_manager.get_milestone_info(next_milestone_id)

            # Try to load saved subtask state for this milestone
            self.subtask_manager.load_state(next_milestone_id)

            # Process with subtasks
            action = self.process_milestone_with_subtasks(
                frame=game_state.get('frame'),
                state=game_state,
                main_milestone=milestone_info
            )

            # Record action
            self.stuck_detector.record_action(action)
            self._last_action = action

            # Check custom milestones
            self._check_custom_milestones(game_state, action)

            return {'action': action}

        except Exception as e:
            print(f"‚ùå Error in subtask step: {e}")
            import traceback
            traceback.print_exc()
            return {'action': 'b'}  # Wait on error
