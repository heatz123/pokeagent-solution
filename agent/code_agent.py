#!/usr/bin/env python3
"""
Code-generating agent that uses OpenAI Vision API to generate Python code
which is then executed to determine game actions.
"""

import openai
import os
import time
import io
import base64
from utils.llm_logger import get_llm_logger
from utils.state_formatter import format_state_for_llm_json, convert_state_to_dict
from utils.milestone_manager import MilestoneManager
from utils.prompt_builder import CodeAgentPromptBuilder, CodePromptConfig
from utils.stuck_detector import StuckDetector
from utils.knowledge_base import KnowledgeBase


class CodeAgent:
    """Agent that generates and executes Python code to determine actions"""

    def __init__(self):
        """Initialize the CodeAgent with OpenAI client and logger"""
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise ValueError("OPENAI_API_KEY environment variable not set")

        self.client = openai.OpenAI(api_key=api_key)
        self.llm_logger = get_llm_logger()
        self.model = "gpt-5-mini"
        self.step_count = 0
        self.last_code_generation_step = 0

        # Milestone manager (like SimpleAgent's objectives)
        self.milestone_manager = MilestoneManager()

        # Stuck detector (threshold=3)
        self.stuck_detector = StuckDetector(threshold=3)

        # Code caching
        self.last_generated_code = None
        self.code_generation_count = 0

        # Execution error tracking
        self.last_execution_error = None

        # Prompt builder for structured prompt generation
        self.prompt_builder = CodeAgentPromptBuilder(
            config=CodePromptConfig(
                include_visual_note=True,
                include_milestones=True,
                include_example_code=True
            )
        )

        # Knowledge base for persistent learning across runs
        self.knowledge_base = KnowledgeBase()

        # Track actions generated by current code (for debugging stuck patterns)
        self.actions_since_last_generation = []

    def step(self, game_state):
        """
        Generate code based on game state and execute it to get action

        Stuckì´ ì•„ë‹ ë•ŒëŠ” ì´ì „ ì½”ë“œ ì¬ì‚¬ìš©, Stuckì¼ ë•Œë§Œ ìƒˆ ì½”ë“œ ìƒì„±

        Args:
            game_state: Dict with keys:
                - 'frame': PIL Image
                - 'player': player info dict
                - 'game': game info dict
                - 'map': map info dict
                - 'visual': visual info dict

        Returns:
            {'action': 'up'} or {'action': ['up', 'a']}
        """
        self.step_count += 1

        # 1. Check for stuck pattern
        is_stuck = self.stuck_detector.check_stuck(game_state)

        # 2. Code selection logic
        try:
            steps_since_generation = self.step_count - self.last_code_generation_step
            if self.last_execution_error or is_stuck or self.last_generated_code is None or steps_since_generation >= 60:
                # ì—ëŸ¬ ìˆê±°ë‚˜, Stuckì´ê±°ë‚˜, ì²« ì‹¤í–‰, ë˜ëŠ” 60ìŠ¤í… ê²½ê³¼ -> ìƒˆ ì½”ë“œ ìƒì„±
                code = self._generate_new_code(game_state, is_stuck)
                self.last_generated_code = code
                self.code_generation_count += 1
                self.last_code_generation_step = self.step_count
            else:
                # Not stuck and no error -> ì´ì „ ì½”ë“œ ì¬ì‚¬ìš©
                code = self.last_generated_code
                print(f"ğŸ”„ Reusing previous code (generation #{self.code_generation_count})")

            # 3. Execute code to get action
            action = self._execute_code(code, game_state)

            # 4. Record action and reset if stuck
            self.stuck_detector.record_action(action)
            self.actions_since_last_generation.append(action)
            if is_stuck:
                self.stuck_detector.reset()

            return {'action': action}

        except Exception as e:
            print(f"âŒ CodeAgent error: {e}")
            return {'action': 'b'}  # Default action on error

    def _generate_new_code(self, game_state, is_stuck: bool) -> str:
        """
        ìƒˆë¡œìš´ ì½”ë“œ ìƒì„± (LLM í˜¸ì¶œ)

        Args:
            game_state: ê²Œì„ ìƒíƒœ
            is_stuck: Stuck ì—¬ë¶€

        Returns:
            ìƒì„±ëœ Python ì½”ë“œ
        """
        # 0. Save previous actions before generating new code, then reset
        previous_actions = self.actions_since_last_generation.copy()
        self.actions_since_last_generation = []

        # 1. Stuck warning ìƒì„±
        stuck_warning = self.stuck_detector.get_stuck_warning()

        # 2. ì´ì „ ì½”ë“œ (stuckì¸ ê²½ìš°ë§Œ, raw codeë§Œ ì „ë‹¬)
        previous_code_raw = ""
        if is_stuck and self.last_generated_code:
            previous_code_raw = self.last_generated_code

        # 3. Stateì™€ milestone ì •ë³´ (JSON í˜•íƒœë¡œ ë³€í™˜)
        state_text = format_state_for_llm_json(game_state)
        screenshot_base64 = self._get_screenshot_base64(game_state)
        milestones = game_state.get('milestones', {})
        next_milestone_info = self.milestone_manager.get_next_milestone_info(milestones)
        current_milestone = next_milestone_info['id'] if next_milestone_info else 'unknown'

        # 4. Knowledge base ê°€ì ¸ì˜¤ê¸°
        knowledge_text = self.knowledge_base.to_prompt_format(limit=20)

        # 5. í”„ë¡¬í”„íŠ¸ ìƒì„± (raw code ì „ë‹¬, í¬ë§·íŒ…ì€ PromptBuilderê°€ ë‹´ë‹¹)
        prompt = self.prompt_builder.build_prompt(
            formatted_state=state_text,
            next_milestone_info=next_milestone_info,
            stuck_warning=stuck_warning,
            previous_code=previous_code_raw,
            execution_error=self.last_execution_error,
            knowledge_base=knowledge_text,
            previous_actions=previous_actions
        )

        # 6. LLM í˜¸ì¶œ
        start = time.time()
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": "You are a Pokemon Emerald AI coding assistant. Generate clean, executable Python code based on visual and text information."
                },
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/png;base64,{screenshot_base64}"
                            }
                        }
                    ] if screenshot_base64 else [{"type": "text", "text": prompt}]
                }
            ],
        )
        duration = time.time() - start

        # 7. ì½”ë“œ ì¶”ì¶œ ë° ë¡œê¹…
        full_response = response.choices[0].message.content
        code = self._extract_code(full_response)

        # 8. Knowledge base ì—…ë°ì´íŠ¸ íŒŒì‹±
        self._parse_and_update_knowledge(full_response, current_milestone)

        self.llm_logger.log_interaction(
            interaction_type="code_generation",
            prompt=prompt,
            response=full_response,
            duration=duration,
            model_info={
                "model": self.model,
                "tokens": {
                    "prompt": response.usage.prompt_tokens,
                    "completion": response.usage.completion_tokens
                }
            }
        )

        # 7. Milestone ì •ë³´ ì¶œë ¥
        if next_milestone_info:
            print(f"ğŸ“ Next Milestone: {next_milestone_info['id']}")
        else:
            print(f"ğŸ† All Milestones Complete!")

        # 8. ì„±ê³µì ìœ¼ë¡œ ìƒì„±í–ˆìœ¼ë©´ ì—ëŸ¬ ì´ˆê¸°í™”
        self.last_execution_error = None

        return code

    def _get_screenshot_base64(self, game_state):
        """Get base64 screenshot from game state"""
        frame = game_state.get('frame')
        if frame:
            buffer = io.BytesIO()
            frame.save(buffer, format='PNG')
            return base64.b64encode(buffer.getvalue()).decode()
        return ""

    def _extract_code(self, text):
        """Extract code from structured LLM response"""
        # Try to find CODE: section first (for structured responses)
        if "CODE:" in text:
            code_section = text.split("CODE:")[1]

            # Extract from code block if present
            if "```python" in code_section:
                return code_section.split("```python")[1].split("```")[0].strip()
            elif "```" in code_section:
                return code_section.split("```")[1].split("```")[0].strip()

            # If no code block, take everything after CODE:
            # until we hit another section or end
            lines = code_section.split('\n')
            code_lines = []
            for line in lines:
                # Stop at next section header
                if any(line.strip().startswith(section) for section in ['ANALYSIS:', 'OBJECTIVES:', 'PLAN:', 'REASONING:']):
                    break
                code_lines.append(line)

            extracted = '\n'.join(code_lines).strip()
            if extracted:
                return extracted

        # Fallback to old behavior (for non-structured responses)
        if "```python" in text:
            return text.split("```python")[1].split("```")[0].strip()
        elif "```" in text:
            return text.split("```")[1].split("```")[0].strip()

        return text.strip()

    def _execute_code(self, code, state):
        """
        Execute generated code and extract action

        Args:
            code: Python code string with run(state) function
            state: Game state dict (raw format)

        Returns:
            action string (e.g., 'up', 'a')
        """
        try:
            # Convert state to same format LLM saw in prompt
            formatted_state = convert_state_to_dict(state)

            # Create execution environment
            exec_globals = {}
            exec(code, exec_globals)

            # Call run function with formatted state
            if 'run' in exec_globals:
                action = exec_globals['run'](formatted_state)

                # Validate action (support single action or list of actions)
                valid_actions = ['a', 'b', 'start', 'select', 'up', 'down', 'left', 'right']

                # Support single action (str)
                if isinstance(action, str):
                    if action.lower() in valid_actions:
                        return action.lower()
                    else:
                        error_msg = f"Invalid action returned: {action}"
                        print(f"âš ï¸ {error_msg}, using 'b'")
                        self.last_execution_error = {
                            'error': error_msg,
                            'code': code
                        }
                        return 'b'

                # Support multiple actions (list)
                elif isinstance(action, list):
                    if len(action) == 0:
                        error_msg = "Empty action list returned"
                        print(f"âš ï¸ {error_msg}, using 'b'")
                        self.last_execution_error = {
                            'error': error_msg,
                            'code': code
                        }
                        return 'b'

                    # Validate each action in the list
                    validated_actions = []
                    for act in action:
                        if isinstance(act, str) and act.lower() in valid_actions:
                            validated_actions.append(act.lower())
                        else:
                            error_msg = f"Invalid action in list: {act}"
                            print(f"âš ï¸ {error_msg}, using 'b'")
                            self.last_execution_error = {
                                'error': error_msg,
                                'code': code
                            }
                            return 'b'

                    return validated_actions  # Return list of validated actions

                # Invalid type
                else:
                    error_msg = f"Invalid action type returned: {type(action).__name__} (expected str or list)"
                    print(f"âš ï¸ {error_msg}, using 'b'")
                    self.last_execution_error = {
                        'error': error_msg,
                        'code': code
                    }
                    return 'b'
            else:
                error_msg = "No 'run' function found in code"
                print(f"âš ï¸ {error_msg}, using 'b'")
                self.last_execution_error = {
                    'error': error_msg,
                    'code': code
                }
                return 'b'

        except Exception as e:
            import traceback
            error_msg = f"Code execution error: {str(e)}"
            traceback_str = traceback.format_exc()

            print(f"âŒ {error_msg}")
            print(f"Code:\n{code}")
            print(traceback_str)

            self.last_execution_error = {
                'error': error_msg,
                'code': code,
                'traceback': traceback_str
            }

            return 'b'  # Default action on error

    def _parse_and_update_knowledge(self, llm_response: str, current_milestone: str):
        """
        Parse LLM response for ADD_KNOWLEDGE commands and update knowledge base

        Args:
            llm_response: Full LLM response text
            current_milestone: Current milestone ID for metadata
        """
        for line in llm_response.split('\n'):
            line = line.strip()
            if line.startswith("ADD_KNOWLEDGE:"):
                # Extract content after "ADD_KNOWLEDGE:"
                content = line.split("ADD_KNOWLEDGE:", 1)[1].strip()
                if content:
                    # Add to knowledge base with current step and milestone
                    self.knowledge_base.add(
                        content=content,
                        step=self.step_count,
                        milestone=current_milestone
                    )
                    print(f"ğŸ“ Knowledge added: {content}")
